<div align="center">
  <img src="assets/decapod-ultra.svg" width="800" alt="Decapod Logo">

  <h2>A Governance Runtime for Autonomous Software Agents</h2>

  <p>
    <strong>Decapod turns "AI wrote code" into "I can merge this."</strong>
  </p>

  <p>
    <a href="https://github.com/DecapodLabs/decapod/actions"><img alt="CI" src="https://github.com/DecapodLabs/decapod/actions/workflows/ci.yml/badge.svg"></a>
    <a href="https://crates.io/crates/decapod"><img alt="Crates.io" src="https://img.shields.io/crates/v/decapod.svg"></a>
  </p>

  <p>
    <strong>Local-first Â· Repo-native Â· Built in Rust ğŸ¦€</strong>
  </p>
</div>

---

## What This Is

**Decapod is agent infrastructure: a governance runtime for autonomous software agents.**

Like Docker is a runtime for containers, Decapod is a runtime for agents. It gives autonomy a place to live that isnâ€™t your chat window: **persistent state**, **binding methodology**, **proof gates**, and **coordination primitives**â€”so agent work becomes shippable, not scary.

Agents can write code. But they canâ€™t reliably **ship** because they:
- forget what they built yesterday (no persistence)
- treat best practices as vibes (no enforcement)
- say â€œdoneâ€ without evidence (no proof gates)
- trip over each other in parallel (no coordination)

You set Decapod up once, then agents operate inside the governed environment. **You donâ€™t touch the internalsâ€”just like you donâ€™t touch individual neurons.**

### What This Is Not

Decapod is not:
- a prompt pack
- an agent framework/library
- a hosted SaaS â€œagent platformâ€
- a review bot that just comments on PRs
- a tool you manually operate (itâ€™s agent infrastructure)

Decapod is an environment: **the place agent work becomes enforceable.**

---

## Getting Started

```bash
cargo install decapod
cd <your-project>
decapod init
```

From that point on, agents operate inside the governed environment. You observe outcomes, review summaries, and merge when proofs pass.

---

## How It Works

### 1) Persistent State (Memory That Survives)

Agents persist work to `.decapod/`: todos, conventions, decisions, proof eventsâ€”durable state that survives sessions and model switches.

You get continuity without re-explaining. Agents get a real memory substrate instead of fragile chat history.

### 2) Enforced Methodology (Constitution as Code)

Decapod ships an embedded constitution: binding contracts for how agents must operate (intent-first flow, authority chains, proof doctrine, store separation, etc).

Generated entrypoints (`CLAUDE.md`, `AGENTS.md`, `GEMINI.md`) require agents to:
- read the constitution before acting
- use the control surface for state mutation (no internal access)
- follow Intent â†’ Architecture â†’ Implementation â†’ Proof
- pass validation gates before claiming â€œdoneâ€

Projects override behavior via `.decapod/OVERRIDE.md` without forking the constitution.

### 3) Proof Gates (Validation Before Promotion)

Promotion isnâ€™t a vibe. Itâ€™s a check that can fail.

Agents must satisfy proof gates before completion is credible. If validation fails, the work isnâ€™t doneâ€”no matter how confident the summary sounds. Evidence required, not assertions.

### 4) Coordination Primitives (So Parallel Doesnâ€™t Mean Chaos)

Decapod standardizes the surfaces agents use to collaborate:
- a shared backlog with audit trail
- shared conventions and preferences
- shared rationale (decisions, constraints, invariants)
- a proof ledger (what passed, what failed, when, and why)
- policy boundaries (trust tiers, risk zones)
- (planned) safe multi-writer state via a DB broker

Multiple agents can work in parallel without collisions, duplicate effort, or lost context.

---

## The Difference

**Without Decapod:**
```
You: â€œAdd OAuth to the login flowâ€
Agent: Writes 500 lines across 8 files
You: Review everything manually
You: Find broken tests, ignored conventions, missing error paths
Agent: Forgets context when you ask for fixes
```

**With Decapod:**
```
You: â€œAdd OAuth to the login flowâ€
Agent: Checks recorded conventions and constraints
Agent: Produces tracked work, records decisions
Agent: Runs proof gates, fixes failures, re-validates
Agent: Marks work done with an auditable trail
You: Review summary and merge
```

---

## Architecture

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Agent Entrypoints (CLAUDE.md, etc)     â”‚  â† Generated by init
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Control Surface (stable interface)     â”‚  â† Agents interact here
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Subsystems (plugin-grade surfaces)     â”‚  â† Domain logic
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Governance Core (validate + doctrine)  â”‚  â† Enforcement layer
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  State Layer (SQLite + event logs)      â”‚  â† Persistence + audit
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Embedded Constitution (methodology)    â”‚  â† Contracts, not tips
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Storage: .decapod/
â”œâ”€â”€ data/         # State (agents write via control surface)
â”œâ”€â”€ generated/    # Entrypoints + derived files (auto-managed)
â””â”€â”€ OVERRIDE.md   # Your repo's policy/conventions
```

You donâ€™t touch `.decapod/data/` directly. Agents use the control surface. Like neuronsâ€”theyâ€™re there, they work, you donâ€™t manipulate them individually.

---

## Subsystems

Decapodâ€™s control surface is organized into subsystems. **Agents interact with these; you observe outcomes.**

Status legend:
- **REAL** = implemented and usable today
- **SPEC** = designed/claimed, but not fully shipped yet

| Subsystem | Purpose | Status |
|----------|---------|--------|
| **todo** | Work tracking with audit trail | REAL |
| **validate** | Proof gate before promotion | REAL |
| **cron** | Scheduled automation | REAL |
| **reflex** | Rule-driven triggers/actions | REAL |
| **docs** | Constitution discovery | REAL |
| **teammate** | User conventions + preferences | SPEC |
| **knowledge** | Project facts + rationale | SPEC |
| **health** | Proof ledger + system state | SPEC |
| **policy** | Risk zones + approvals | SPEC |
| **trust** | Autonomy tiers based on proof history | SPEC |
| **context** | Token budget management | SPEC |
| **archive** | Session history indexing | SPEC |
| **watcher** | Integrity checks | SPEC |
| **heartbeat** | One-shot system summary | SPEC |
| **feedback** | Preference refinement | SPEC |
| **db_broker** | Multi-agent SQLite safety (write serialization) | SPEC |

If you want the thesis behind these surfaces, the whitepaper is the â€œwhyâ€ and â€œhow.â€

---

## Real-World Scenarios

### Scenario 1: Preference Memory

You tell an agent once: â€œAlways use my SSH key for commits. Never add yourself as a contributor.â€

That preference becomes durable state. Every future agent session can check it. You never explain again.

### Scenario 2: Multi-Agent Feature Work

Work is tracked. Agents claim separate items, operate in parallel, and must pass proof gates before marking work done. No duplicate effort. No coordination bugs. No lost context.

### Scenario 3: Proof-Gated Promotion

An agent thinks itâ€™s done. Proof gates fail. It canâ€™t credibly claim completion until it fixes the failures and re-validates. Thatâ€™s the difference between autonomy and theater.

---

## Who This Is For

âœ… Youâ€™re shipping production code with AI agents<br>
âœ… You want discipline enforced by the environment<br>
âœ… You want parallel agents without turning the repo into lore<br>
âœ… You merge to `main` (not just demoing prompts)<br>
âœ… You want an AI companion for building premium software<br>
âœ… You want â€œAI vibesâ€ with guardrails and customizable enforceable workflows<br>

---

## Ecosystem Status

**Real today (foundation):**
- Local-first repo runtime (initialize once, agents use it)
- Constitution routing + discovery (agents read, projects override)
- Proof gates (validation must pass)
- Core subsystems operational

**In progress:**
- DB Broker (multi-agent safe writes)
- Handoff/context passing surfaces

**Planned:**
- Trust automation (earn autonomy through proof history)
- Policy DSL (risk zones with approvals)
- Pattern learning (conventions inferred from repo)

---

<div align="center">
  <strong>Agents will ship code whether you're ready or not.</strong><br>
  <sub>Make them earn the merge.</sub>
  <br><br>
  <a href="https://github.com/DecapodLabs/decapod">â­ Star on GitHub</a> â€¢
  <a href="https://crates.io/crates/decapod">ğŸ“¦ Crates.io</a> â€¢
  <a href="WHITEPAPER.md">ğŸ“„ Whitepaper</a> â€¢
  <a href="https://ko-fi.com/decapodlabs">â˜• Support</a>
</div>

---

<div align="center">
  <sub>
    Built with Decapod Â· Proven with Decapod Â· Shipped with Decapod
  </sub>
</div>
